//
//  IntegratedViewModels.swift
//  ShaydZ-AVMo
//
//  Generated by iOS Integration Tool
//

import Foundation
import Combine

// MARK: - Authentication View Model

class AuthenticationViewModel: ObservableObject {
    @Published var isAuthenticated = false
    @Published var currentUser: User?
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private let networkService = NetworkService.shared
    private var cancellables = Set<AnyCancellable>()
    
    func login(username: String, password: String) {
        isLoading = true
        errorMessage = nil
        
        networkService.login(username: username, password: password)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] response in
                    self?.isAuthenticated = true
                    self?.currentUser = response.user
                }
            )
            .store(in: &cancellables)
    }
    
    func logout() {
        networkService.logout()
        isAuthenticated = false
        currentUser = nil
    }
}

// MARK: - App Catalog View Model

class AppCatalogViewModel: ObservableObject {
    @Published var apps: [App] = []
    @Published var filteredApps: [App] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var searchText = "" {
        didSet {
            filterApps()
        }
    }
    
    private let networkService = NetworkService.shared
    private var cancellables = Set<AnyCancellable>()
    
    func loadApps() {
        isLoading = true
        errorMessage = nil
        
        networkService.fetchApps()
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] apps in
                    self?.apps = apps
                    self?.filterApps()
                }
            )
            .store(in: &cancellables)
    }
    
    private func filterApps() {
        if searchText.isEmpty {
            filteredApps = apps
        } else {
            filteredApps = apps.filter { app in
                app.name.lowercased().contains(searchText.lowercased()) ||
                app.category.lowercased().contains(searchText.lowercased())
            }
        }
    }
    
    func searchApps(query: String) {
        guard !query.isEmpty else {
            filterApps()
            return
        }
        
        isLoading = true
        
        networkService.searchApps(query: query)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] apps in
                    self?.filteredApps = apps
                }
            )
            .store(in: &cancellables)
    }
}

// MARK: - Virtual Machine View Model

class VirtualMachineViewModel: ObservableObject {
    @Published var virtualMachines: [VirtualMachine] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var actionInProgress: String?
    
    private let networkService = NetworkService.shared
    private var cancellables = Set<AnyCancellable>()
    
    func loadVirtualMachines() {
        isLoading = true
        errorMessage = nil
        
        networkService.fetchVirtualMachines()
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] vms in
                    self?.virtualMachines = vms
                }
            )
            .store(in: &cancellables)
    }
    
    func startVM(_ vm: VirtualMachine) {
        actionInProgress = vm.id
        
        networkService.startVirtualMachine(vmId: vm.id)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.actionInProgress = nil
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] response in
                    if response.success {
                        self?.loadVirtualMachines()
                    } else {
                        self?.errorMessage = response.message
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    func stopVM(_ vm: VirtualMachine) {
        actionInProgress = vm.id
        
        networkService.stopVirtualMachine(vmId: vm.id)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.actionInProgress = nil
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] response in
                    if response.success {
                        self?.loadVirtualMachines()
                    } else {
                        self?.errorMessage = response.message
                    }
                }
            )
            .store(in: &cancellables)
    }
}