import Foundation
import Combine

class VulnerabilityScanner {
    // Singleton instance
    static let shared = VulnerabilityScanner()
    
    private var cancellables = Set<AnyCancellable>()
    
    // Published properties
    @Published var isScanning = false
    @Published var scanProgress: Double = 0.0
    @Published var error: String?
    
    private init() {
        // Private initialization to enforce singleton pattern
    }
    
    func scanWebApplication(url: URL) -> AnyPublisher<[Vulnerability], APIError> {
        guard !isScanning else {
            return Fail(error: APIError.requestFailed("Scan already in progress"))
                .eraseToAnyPublisher()
        }
        
        isScanning = true
        scanProgress = 0.0
        error = nil
        
        // In a real implementation, we would perform actual HTTP requests to test vulnerabilities
        // For this demo, we'll simulate finding vulnerabilities
        
        return simulateWebVulnerabilityScan(url: url)
            .handleEvents(
                receiveOutput: { [weak self] _ in
                    self?.isScanning = false
                    self?.scanProgress = 1.0
                },
                receiveCompletion: { [weak self] completion in
                    self?.isScanning = false
                    if case .failure(let error) = completion {
                        self?.error = error.localizedDescription
                    }
                },
                receiveCancel: { [weak self] in
                    self?.isScanning = false
                }
            )
            .eraseToAnyPublisher()
    }
    
    func scanNetworkService(host: String, port: Int) -> AnyPublisher<ServiceVulnerability, APIError> {
        guard !isScanning else {
            return Fail(error: APIError.requestFailed("Scan already in progress"))
                .eraseToAnyPublisher()
        }
        
        isScanning = true
        scanProgress = 0.0
        error = nil
        
        // In a real implementation, we would connect to the service and test for vulnerabilities
        // For this demo, we'll simulate finding vulnerabilities
        
        return simulateNetworkServiceVulnerabilityScan(host: host, port: port)
            .handleEvents(
                receiveOutput: { [weak self] _ in
                    self?.isScanning = false
                    self?.scanProgress = 1.0
                },
                receiveCompletion: { [weak self] completion in
                    self?.isScanning = false
                    if case .failure(let error) = completion {
                        self?.error = error.localizedDescription
                    }
                },
                receiveCancel: { [weak self] in
                    self?.isScanning = false
                }
            )
            .eraseToAnyPublisher()
    }
    
    // MARK: - Simulation Methods
    
    private func simulateWebVulnerabilityScan(url: URL) -> AnyPublisher<[Vulnerability], APIError> {
        // Use the domain and path to simulate different vulnerabilities
        let domain = url.host ?? ""
        let path = url.path
        
        var simulatedVulnerabilities: [Vulnerability] = []
        
        // Add SQL injection vulnerability for paths containing "search", "login", or "user"
        if path.contains("search") || path.contains("login") || path.contains("user") {
            simulatedVulnerabilities.append(
                Vulnerability(
                    type: .sqlInjection,
                    severity: .high,
                    description: "SQL Injection vulnerability detected in search parameter",
                    affectedComponent: "\(path) endpoint",
                    remediationSteps: "Use prepared statements or parameterized queries instead of building SQL queries through string concatenation."
                )
            )
        }
        
        // Add XSS vulnerability for paths containing "comment", "post", or "message"
        if path.contains("comment") || path.contains("post") || path.contains("message") {
            simulatedVulnerabilities.append(
                Vulnerability(
                    type: .xss,
                    severity: .medium,
                    description: "Cross-site scripting vulnerability in user input fields",
                    affectedComponent: "\(path) form submission",
                    remediationSteps: "Implement proper input validation and output encoding."
                )
            )
        }
        
        // Add CSRF vulnerability for paths containing "admin", "dashboard", or "profile"
        if path.contains("admin") || path.contains("dashboard") || path.contains("profile") {
            simulatedVulnerabilities.append(
                Vulnerability(
                    type: .csrf,
                    severity: .medium,
                    description: "Cross-site request forgery vulnerability in form submission",
                    affectedComponent: "\(path) form actions",
                    remediationSteps: "Implement anti-CSRF tokens in all forms."
                )
            )
        }
        
        // Add insecure header vulnerability for all scans
        simulatedVulnerabilities.append(
            Vulnerability(
                type: .insecureHeaders,
                severity: .low,
                description: "Missing security headers (Content-Security-Policy, X-XSS-Protection)",
                affectedComponent: "HTTP Response Headers",
                remediationSteps: "Configure web server to include proper security headers."
            )
        )
        
        // Add domain-based vulnerabilities
        if domain.contains("wordpress") || domain.contains("wp") {
            simulatedVulnerabilities.append(
                Vulnerability(
                    type: .outdatedSoftware,
                    severity: .high,
                    description: "Outdated WordPress installation detected",
                    affectedComponent: "Content Management System",
                    remediationSteps: "Update WordPress to the latest version."
                )
            )
        }
        
        if domain.contains("shop") || domain.contains("store") || domain.contains("cart") {
            simulatedVulnerabilities.append(
                Vulnerability(
                    type: .other("Insecure Payment Process"),
                    severity: .critical,
                    description: "Payment information transmitted over insecure channel",
                    affectedComponent: "Checkout Process",
                    remediationSteps: "Implement SSL/TLS for all payment pages and transactions."
                )
            )
        }
        
        // Simulate scanning progress
        return Timer.publish(every: 0.5, on: .main, in: .common)
            .autoconnect()
            .scan(0) { count, _ in count + 1 }
            .map { [weak self] count -> Double in
                let progress = Double(count) / 10.0
                self?.scanProgress = min(0.9, progress)
                return progress
            }
            .filter { $0 >= 0.9 }
            .map { _ in simulatedVulnerabilities }
            .setFailureType(to: APIError.self)
            .first()
            .eraseToAnyPublisher()
    }
    
    private func simulateNetworkServiceVulnerabilityScan(host: String, port: Int) -> AnyPublisher<ServiceVulnerability, APIError> {
        // Use the port to determine the service type and potential vulnerabilities
        var serviceName = "Unknown"
        var version: String? = nil
        var vulnerabilities: [Vulnerability] = []
        
        switch port {
        case 22:
            serviceName = "SSH"
            version = "OpenSSH 7.6p1"
            vulnerabilities.append(
                Vulnerability(
                    type: .outdatedSoftware,
                    severity: .medium,
                    description: "Outdated SSH version with known vulnerabilities",
                    affectedComponent: "SSH Server",
                    remediationSteps: "Update to the latest version of OpenSSH."
                )
            )
            
        case 80, 8080:
            serviceName = "HTTP"
            version = "Apache/2.4.29"
            vulnerabilities.append(
                Vulnerability(
                    type: .insecureHeaders,
                    severity: .low,
                    description: "Server reveals version information",
                    affectedComponent: "HTTP Headers",
                    remediationSteps: "Configure web server to hide version information."
                )
            )
            
            vulnerabilities.append(
                Vulnerability(
                    type: .other("Directory Listing"),
                    severity: .medium,
                    description: "Directory listing enabled",
                    affectedComponent: "Web Server Configuration",
                    remediationSteps: "Disable directory listing in web server configuration."
                )
            )
            
        case 443, 8443:
            serviceName = "HTTPS"
            version = "nginx/1.14.0"
            vulnerabilities.append(
                Vulnerability(
                    type: .other("Weak SSL/TLS Configuration"),
                    severity: .high,
                    description: "Server supports deprecated SSL/TLS protocols",
                    affectedComponent: "TLS Configuration",
                    remediationSteps: "Disable SSL 3.0, TLS 1.0, and TLS 1.1. Only enable TLS 1.2 and TLS 1.3."
                )
            )
            
        case 21:
            serviceName = "FTP"
            version = "vsftpd 3.0.3"
            vulnerabilities.append(
                Vulnerability(
                    type: .other("Clear Text Authentication"),
                    severity: .critical,
                    description: "FTP transmits credentials in clear text",
                    affectedComponent: "FTP Service",
                    remediationSteps: "Replace FTP with SFTP or FTPS."
                )
            )
            
        case 3306:
            serviceName = "MySQL"
            version = "MySQL 5.7.32"
            vulnerabilities.append(
                Vulnerability(
                    type: .defaultCredentials,
                    severity: .critical,
                    description: "Default or weak credentials in use",
                    affectedComponent: "Database Authentication",
                    remediationSteps: "Change default passwords and implement strong password policy."
                )
            )
            
        case 5432:
            serviceName = "PostgreSQL"
            version = "PostgreSQL 9.5.25"
            vulnerabilities.append(
                Vulnerability(
                    type: .outdatedSoftware,
                    severity: .high,
                    description: "End-of-life PostgreSQL version",
                    affectedComponent: "Database Server",
                    remediationSteps: "Upgrade to a supported PostgreSQL version."
                )
            )
            
        default:
            serviceName = "Unknown"
            version = nil
            
            // Generic vulnerability for unknown services
            vulnerabilities.append(
                Vulnerability(
                    type: .other("Unknown Service"),
                    severity: .medium,
                    description: "Unidentified service running on non-standard port",
                    affectedComponent: "Network Service",
                    remediationSteps: "Verify the service is authorized and required. If not, disable it."
                )
            )
        }
        
        let serviceVulnerability = ServiceVulnerability(
            service: serviceName,
            version: version,
            vulnerabilities: vulnerabilities
        )
        
        // Simulate scanning progress
        return Timer.publish(every: 0.3, on: .main, in: .common)
            .autoconnect()
            .scan(0) { count, _ in count + 1 }
            .map { [weak self] count -> Double in
                let progress = Double(count) / 12.0
                self?.scanProgress = min(0.95, progress)
                return progress
            }
            .filter { $0 >= 0.95 }
            .map { _ in serviceVulnerability }
            .setFailureType(to: APIError.self)
            .first()
            .eraseToAnyPublisher()
    }
}
