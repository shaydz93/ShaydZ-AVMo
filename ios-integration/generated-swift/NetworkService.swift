//
//  NetworkService.swift
//  ShaydZ-AVMo
//
//  Generated by iOS Integration Tool
//

import Foundation
import Combine

class NetworkService: ObservableObject {
    static let shared = NetworkService()
    
    private let baseURL = "http://localhost:8080"
    private let authServiceURL = "http://localhost:8081"
    private let appCatalogURL = "http://localhost:8083"
    private let vmOrchestratorURL = "http://localhost:8082"
    
    private var authToken: String?
    private var cancellables = Set<AnyCancellable>()
    
    private init() {}
    
    // MARK: - Authentication
    
    func login(username: String, password: String) -> AnyPublisher<AuthResponse, Error> {
        let loginData = LoginRequest(username: username, password: password)
        
        return performRequest(
            url: "\(authServiceURL)/login",
            method: "POST",
            body: loginData,
            responseType: AuthResponse.self
        )
        .handleEvents(receiveOutput: { [weak self] response in
            self?.authToken = response.token
        })
        .eraseToAnyPublisher()
    }
    
    func logout() {
        authToken = nil
    }
    
    // MARK: - App Catalog
    
    func fetchApps() -> AnyPublisher<[App], Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\(appCatalogURL)/apps",
            method: "GET",
            headers: ["Authorization": "Bearer \(token)"],
            responseType: [App].self
        )
    }
    
    func searchApps(query: String) -> AnyPublisher<[App], Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\(appCatalogURL)/apps/search?q=\(query)",
            method: "GET",
            headers: ["Authorization": "Bearer \(token)"],
            responseType: [App].self
        )
    }
    
    // MARK: - Virtual Machines
    
    func fetchVirtualMachines() -> AnyPublisher<[VirtualMachine], Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\(vmOrchestratorURL)/vms",
            method: "GET",
            headers: ["Authorization": "Bearer \(token)"],
            responseType: [VirtualMachine].self
        )
    }
    
    func startVirtualMachine(vmId: String) -> AnyPublisher<VMActionResponse, Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\(vmOrchestratorURL)/vms/\(vmId)/start",
            method: "POST",
            headers: ["Authorization": "Bearer \(token)"],
            responseType: VMActionResponse.self
        )
    }
    
    func stopVirtualMachine(vmId: String) -> AnyPublisher<VMActionResponse, Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\(vmOrchestratorURL)/vms/\(vmId)/stop",
            method: "POST",
            headers: ["Authorization": "Bearer \(token)"],
            responseType: VMActionResponse.self
        )
    }
    
    // MARK: - Generic Request Method
    
    private func performRequest<T: Codable>(
        url: String,
        method: String = "GET",
        headers: [String: String] = [:],
        body: Codable? = nil,
        responseType: T.Type
    ) -> AnyPublisher<T, Error> {
        
        guard let requestURL = URL(string: url) else {
            return Fail(error: NetworkError.invalidURL)
                .eraseToAnyPublisher()
        }
        
        var request = URLRequest(url: requestURL)
        request.httpMethod = method
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Add headers
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }
        
        // Add body if provided
        if let body = body {
            do {
                request.httpBody = try JSONEncoder().encode(body)
            } catch {
                return Fail(error: error)
                    .eraseToAnyPublisher()
            }
        }
        
        return URLSession.shared.dataTaskPublisher(for: request)
            .map(.data)
            .decode(type: responseType, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}

// MARK: - Network Error Types

enum NetworkError: Error, LocalizedError {
    case invalidURL
    case unauthorized
    case serverError(Int)
    case noData
    case decodingError
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid URL"
        case .unauthorized:
            return "Unauthorized access"
        case .serverError(let code):
            return "Server error with code: \(code)"
        case .noData:
            return "No data received"
        case .decodingError:
            return "Failed to decode response"
        }
    }
}

// MARK: - Request/Response Models

struct LoginRequest: Codable {
    let username: String
    let password: String
}

struct AuthResponse: Codable {
    let token: String
    let user: User
}

struct User: Codable {
    let id: String
    let username: String
    let email: String?
}

struct App: Codable, Identifiable {
    let id: String
    let name: String
    let category: String
    let description: String
    let icon: String?
    let version: String
    let isInstalled: Bool
}

struct VirtualMachine: Codable, Identifiable {
    let id: String
    let name: String
    let status: String
    let cpuCores: Int
    let ramMB: Int
    let diskGB: Int
}

struct VMActionResponse: Codable {
    let success: Bool
    let message: String
    let vmId: String
}