// Shared SwiftUI code generation utilities
const fs = require('fs').promises;
const path = require('path');

class SwiftCodeGenerator {
    constructor() {
        this.indentLevel = 0;
    }
    
    indent(level = this.indentLevel) {
        return '    '.repeat(level);
    }
    
    increaseIndent() {
        this.indentLevel++;
        return this;
    }
    
    decreaseIndent() {
        this.indentLevel = Math.max(0, this.indentLevel - 1);
        return this;
    }
    
    generateImports(imports = ['Foundation', 'SwiftUI', 'Combine']) {
        return imports.map(imp => `import ${imp}`).join('\n') + '\n\n';
    }
    
    generateHeader(filename, description = 'Generated by iOS Integration Tool') {
        return `//
//  ${filename}
//  ShaydZ-AVMo
//
//  ${description}
//

`;
    }
    
    generateClass(className, superclass = 'ObservableObject', properties = [], methods = []) {
        let code = `class ${className}`;
        if (superclass) {
            code += `: ${superclass}`;
        }
        code += ' {\n';
        
        this.increaseIndent();
        
        // Add properties
        if (properties.length > 0) {
            code += properties.map(prop => this.indent() + prop).join('\n') + '\n\n';
        }
        
        // Add methods  
        if (methods.length > 0) {
            code += methods.map(method => this.formatMethod(method)).join('\n\n') + '\n';
        }
        
        this.decreaseIndent();
        code += '}\n';
        
        return code;
    }
    
    generateStruct(structName, properties = []) {
        let code = `struct ${structName}: Codable {\n`;
        this.increaseIndent();
        
        if (properties.length > 0) {
            code += properties.map(prop => this.indent() + prop).join('\n') + '\n';
        }
        
        this.decreaseIndent();
        code += '}\n';
        
        return code;
    }
    
    generateEnum(enumName, cases = [], rawType = null) {
        let code = `enum ${enumName}`;
        if (rawType) {
            code += `: ${rawType}`;
        }
        code += ' {\n';
        
        this.increaseIndent();
        cases.forEach(caseItem => {
            code += this.indent() + `case ${caseItem}\n`;
        });
        this.decreaseIndent();
        
        code += '}\n';
        return code;
    }
    
    generatePublishedProperty(name, type, defaultValue = null) {
        let prop = `@Published var ${name}: ${type}`;
        if (defaultValue !== null) {
            prop += ` = ${defaultValue}`;
        }
        return prop;
    }
    
    generateCombineMethod(methodName, parameters = [], returnType = 'AnyPublisher<Void, Error>', body = []) {
        let method = `${this.indent()}func ${methodName}(`;
        
        if (parameters.length > 0) {
            method += parameters.join(', ');
        }
        
        method += `) -> ${returnType} {\n`;
        
        this.increaseIndent();
        body.forEach(line => {
            method += this.indent() + line + '\n';
        });
        this.decreaseIndent();
        
        method += this.indent() + '}';
        
        return method;
    }
    
    formatMethod(method) {
        if (typeof method === 'string') {
            return this.indent() + method;
        }
        
        // For complex method objects
        let code = this.indent();
        if (method.accessibility) {
            code += `${method.accessibility} `;
        }
        code += `func ${method.name}(`;
        
        if (method.parameters && method.parameters.length > 0) {
            code += method.parameters.join(', ');
        }
        
        code += ')';
        
        if (method.returnType) {
            code += ` -> ${method.returnType}`;
        }
        
        code += ' {\n';
        
        this.increaseIndent();
        if (method.body && method.body.length > 0) {
            method.body.forEach(line => {
                code += this.indent() + line + '\n';
            });
        }
        this.decreaseIndent();
        
        code += this.indent() + '}';
        
        return code;
    }
    
    async writeToFile(filePath, content) {
        await fs.mkdir(path.dirname(filePath), { recursive: true });
        await fs.writeFile(filePath, content, 'utf8');
    }
    
    static generateViewModelTemplate(className, services = []) {
        const generator = new SwiftCodeGenerator();
        
        let code = generator.generateHeader(`${className}.swift`);
        code += generator.generateImports();
        
        // Generate properties
        const properties = [
            generator.generatePublishedProperty('isLoading', 'Bool', 'false'),
            generator.generatePublishedProperty('errorMessage', 'String?', 'nil'),
            '',
            'private var cancellables = Set<AnyCancellable>()'
        ];
        
        // Add service dependencies
        services.forEach(service => {
            properties.unshift(`private let ${service.name} = ${service.type}.shared`);
        });
        
        const methods = [
            {
                accessibility: 'private',
                name: 'handleError',
                parameters: ['_ error: Error'],
                body: [
                    'DispatchQueue.main.async { [weak self] in',
                    '    self?.isLoading = false',
                    '    self?.errorMessage = error.localizedDescription',
                    '}'
                ]
            }
        ];
        
        code += generator.generateClass(className, 'ObservableObject', properties, methods);
        
        return code;
    }
}

module.exports = SwiftCodeGenerator;
