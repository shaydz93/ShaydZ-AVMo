#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const chalk = require('chalk');

class IOSSwiftCodeGenerator {
  constructor() {
    this.outputDir = path.join(__dirname, '..', 'generated-swift');
  }

  generateNetworkService() {
    return `//
//  NetworkService.swift
//  ShaydZ-AVMo
//
//  Generated by iOS Integration Tool
//

import Foundation
import Combine

class NetworkService: ObservableObject {
    static let shared = NetworkService()
    
    private let baseURL = "http://localhost:8080"
    private let authServiceURL = "http://localhost:8081"
    private let appCatalogURL = "http://localhost:8083"
    private let vmOrchestratorURL = "http://localhost:8082"
    
    private var authToken: String?
    private var cancellables = Set<AnyCancellable>()
    
    private init() {}
    
    // MARK: - Authentication
    
    func login(username: String, password: String) -> AnyPublisher<AuthResponse, Error> {
        let loginData = LoginRequest(username: username, password: password)
        
        return performRequest(
            url: "\\(authServiceURL)/login",
            method: "POST",
            body: loginData,
            responseType: AuthResponse.self
        )
        .handleEvents(receiveOutput: { [weak self] response in
            self?.authToken = response.token
        })
        .eraseToAnyPublisher()
    }
    
    func logout() {
        authToken = nil
    }
    
    // MARK: - App Catalog
    
    func fetchApps() -> AnyPublisher<[App], Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\\(appCatalogURL)/apps",
            method: "GET",
            headers: ["Authorization": "Bearer \\(token)"],
            responseType: [App].self
        )
    }
    
    func searchApps(query: String) -> AnyPublisher<[App], Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\\(appCatalogURL)/apps/search?q=\\(query)",
            method: "GET",
            headers: ["Authorization": "Bearer \\(token)"],
            responseType: [App].self
        )
    }
    
    // MARK: - Virtual Machines
    
    func fetchVirtualMachines() -> AnyPublisher<[VirtualMachine], Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\\(vmOrchestratorURL)/vms",
            method: "GET",
            headers: ["Authorization": "Bearer \\(token)"],
            responseType: [VirtualMachine].self
        )
    }
    
    func startVirtualMachine(vmId: String) -> AnyPublisher<VMActionResponse, Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\\(vmOrchestratorURL)/vms/\\(vmId)/start",
            method: "POST",
            headers: ["Authorization": "Bearer \\(token)"],
            responseType: VMActionResponse.self
        )
    }
    
    func stopVirtualMachine(vmId: String) -> AnyPublisher<VMActionResponse, Error> {
        guard let token = authToken else {
            return Fail(error: NetworkError.unauthorized)
                .eraseToAnyPublisher()
        }
        
        return performRequest(
            url: "\\(vmOrchestratorURL)/vms/\\(vmId)/stop",
            method: "POST",
            headers: ["Authorization": "Bearer \\(token)"],
            responseType: VMActionResponse.self
        )
    }
    
    // MARK: - Generic Request Method
    
    private func performRequest<T: Codable>(
        url: String,
        method: String = "GET",
        headers: [String: String] = [:],
        body: Codable? = nil,
        responseType: T.Type
    ) -> AnyPublisher<T, Error> {
        
        guard let requestURL = URL(string: url) else {
            return Fail(error: NetworkError.invalidURL)
                .eraseToAnyPublisher()
        }
        
        var request = URLRequest(url: requestURL)
        request.httpMethod = method
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Add headers
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }
        
        // Add body if provided
        if let body = body {
            do {
                request.httpBody = try JSONEncoder().encode(body)
            } catch {
                return Fail(error: error)
                    .eraseToAnyPublisher()
            }
        }
        
        return URLSession.shared.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: responseType, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}

// MARK: - Network Error Types

enum NetworkError: Error, LocalizedError {
    case invalidURL
    case unauthorized
    case serverError(Int)
    case noData
    case decodingError
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid URL"
        case .unauthorized:
            return "Unauthorized access"
        case .serverError(let code):
            return "Server error with code: \\(code)"
        case .noData:
            return "No data received"
        case .decodingError:
            return "Failed to decode response"
        }
    }
}

// MARK: - Request/Response Models

struct LoginRequest: Codable {
    let username: String
    let password: String
}

struct AuthResponse: Codable {
    let token: String
    let user: User
}

struct User: Codable {
    let id: String
    let username: String
    let email: String?
}

struct App: Codable, Identifiable {
    let id: String
    let name: String
    let category: String
    let description: String
    let icon: String?
    let version: String
    let isInstalled: Bool
}

struct VirtualMachine: Codable, Identifiable {
    let id: String
    let name: String
    let status: String
    let cpuCores: Int
    let ramMB: Int
    let diskGB: Int
}

struct VMActionResponse: Codable {
    let success: Bool
    let message: String
    let vmId: String
}`;
  }

  generateViewModels() {
    return `//
//  IntegratedViewModels.swift
//  ShaydZ-AVMo
//
//  Generated by iOS Integration Tool
//

import Foundation
import Combine

// MARK: - Authentication View Model

class AuthenticationViewModel: ObservableObject {
    @Published var isAuthenticated = false
    @Published var currentUser: User?
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private let networkService = NetworkService.shared
    private var cancellables = Set<AnyCancellable>()
    
    func login(username: String, password: String) {
        isLoading = true
        errorMessage = nil
        
        networkService.login(username: username, password: password)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] response in
                    self?.isAuthenticated = true
                    self?.currentUser = response.user
                }
            )
            .store(in: &cancellables)
    }
    
    func logout() {
        networkService.logout()
        isAuthenticated = false
        currentUser = nil
    }
}

// MARK: - App Catalog View Model

class AppCatalogViewModel: ObservableObject {
    @Published var apps: [App] = []
    @Published var filteredApps: [App] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var searchText = "" {
        didSet {
            filterApps()
        }
    }
    
    private let networkService = NetworkService.shared
    private var cancellables = Set<AnyCancellable>()
    
    func loadApps() {
        isLoading = true
        errorMessage = nil
        
        networkService.fetchApps()
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] apps in
                    self?.apps = apps
                    self?.filterApps()
                }
            )
            .store(in: &cancellables)
    }
    
    private func filterApps() {
        if searchText.isEmpty {
            filteredApps = apps
        } else {
            filteredApps = apps.filter { app in
                app.name.lowercased().contains(searchText.lowercased()) ||
                app.category.lowercased().contains(searchText.lowercased())
            }
        }
    }
    
    func searchApps(query: String) {
        guard !query.isEmpty else {
            filterApps()
            return
        }
        
        isLoading = true
        
        networkService.searchApps(query: query)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] apps in
                    self?.filteredApps = apps
                }
            )
            .store(in: &cancellables)
    }
}

// MARK: - Virtual Machine View Model

class VirtualMachineViewModel: ObservableObject {
    @Published var virtualMachines: [VirtualMachine] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var actionInProgress: String?
    
    private let networkService = NetworkService.shared
    private var cancellables = Set<AnyCancellable>()
    
    func loadVirtualMachines() {
        isLoading = true
        errorMessage = nil
        
        networkService.fetchVirtualMachines()
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] vms in
                    self?.virtualMachines = vms
                }
            )
            .store(in: &cancellables)
    }
    
    func startVM(_ vm: VirtualMachine) {
        actionInProgress = vm.id
        
        networkService.startVirtualMachine(vmId: vm.id)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.actionInProgress = nil
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] response in
                    if response.success {
                        self?.loadVirtualMachines()
                    } else {
                        self?.errorMessage = response.message
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    func stopVM(_ vm: VirtualMachine) {
        actionInProgress = vm.id
        
        networkService.stopVirtualMachine(vmId: vm.id)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.actionInProgress = nil
                    if case .failure(let error) = completion {
                        self?.errorMessage = error.localizedDescription
                    }
                },
                receiveValue: { [weak self] response in
                    if response.success {
                        self?.loadVirtualMachines()
                    } else {
                        self?.errorMessage = response.message
                    }
                }
            )
            .store(in: &cancellables)
    }
}`;
  }

  generateSwiftUI() {
    return `//
//  IntegratedViews.swift
//  ShaydZ-AVMo
//
//  Generated by iOS Integration Tool
//

import SwiftUI

// MARK: - Main App View with Integration

struct IntegratedAppView: View {
    @StateObject private var authVM = AuthenticationViewModel()
    @StateObject private var appCatalogVM = AppCatalogViewModel()
    @StateObject private var vmVM = VirtualMachineViewModel()
    
    var body: some View {
        Group {
            if authVM.isAuthenticated {
                TabView {
                    AppCatalogIntegratedView()
                        .tabItem {
                            Image(systemName: "square.grid.3x3")
                            Text("Apps")
                        }
                        .environmentObject(appCatalogVM)
                    
                    VirtualMachineIntegratedView()
                        .tabItem {
                            Image(systemName: "desktopcomputer")
                            Text("VMs")
                        }
                        .environmentObject(vmVM)
                    
                    ProfileView()
                        .tabItem {
                            Image(systemName: "person.circle")
                            Text("Profile")
                        }
                        .environmentObject(authVM)
                }
            } else {
                LoginIntegratedView()
                    .environmentObject(authVM)
            }
        }
        .alert("Error", isPresented: .constant(authVM.errorMessage != nil)) {
            Button("OK") {
                authVM.errorMessage = nil
            }
        } message: {
            if let error = authVM.errorMessage {
                Text(error)
            }
        }
    }
}

// MARK: - Login View with Integration

struct LoginIntegratedView: View {
    @EnvironmentObject var authVM: AuthenticationViewModel
    @State private var username = "demo"
    @State private var password = "password"
    
    var body: some View {
        VStack(spacing: 20) {
            VStack(spacing: 10) {
                Image(systemName: "cube.box.fill")
                    .font(.system(size: 80))
                    .foregroundColor(.blue)
                
                Text("ShaydZ AVMo")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                
                Text("Virtual Mobile Infrastructure")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            VStack(spacing: 15) {
                TextField("Username", text: $username)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .autocapitalization(.none)
                
                SecureField("Password", text: $password)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                
                Button(action: {
                    authVM.login(username: username, password: password)
                }) {
                    HStack {
                        if authVM.isLoading {
                            ProgressView()
                                .scaleEffect(0.8)
                        }
                        Text("Login")
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(10)
                }
                .disabled(authVM.isLoading)
            }
            
            Spacer()
        }
        .padding()
    }
}

// MARK: - App Catalog View with Integration

struct AppCatalogIntegratedView: View {
    @EnvironmentObject var appCatalogVM: AppCatalogViewModel
    
    var body: some View {
        NavigationView {
            VStack {
                SearchBar(text: $appCatalogVM.searchText)
                
                if appCatalogVM.isLoading {
                    ProgressView("Loading apps...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    List(appCatalogVM.filteredApps) { app in
                        AppRowView(app: app)
                    }
                }
            }
            .navigationTitle("App Catalog")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Refresh") {
                        appCatalogVM.loadApps()
                    }
                }
            }
        }
        .onAppear {
            appCatalogVM.loadApps()
        }
        .alert("Error", isPresented: .constant(appCatalogVM.errorMessage != nil)) {
            Button("OK") {
                appCatalogVM.errorMessage = nil
            }
        } message: {
            if let error = appCatalogVM.errorMessage {
                Text(error)
            }
        }
    }
}

// MARK: - Virtual Machine View with Integration

struct VirtualMachineIntegratedView: View {
    @EnvironmentObject var vmVM: VirtualMachineViewModel
    
    var body: some View {
        NavigationView {
            VStack {
                if vmVM.isLoading {
                    ProgressView("Loading virtual machines...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    List(vmVM.virtualMachines) { vm in
                        VMRowView(vm: vm, vmVM: vmVM)
                    }
                }
            }
            .navigationTitle("Virtual Machines")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Refresh") {
                        vmVM.loadVirtualMachines()
                    }
                }
            }
        }
        .onAppear {
            vmVM.loadVirtualMachines()
        }
        .alert("Error", isPresented: .constant(vmVM.errorMessage != nil)) {
            Button("OK") {
                vmVM.errorMessage = nil
            }
        } message: {
            if let error = vmVM.errorMessage {
                Text(error)
            }
        }
    }
}

// MARK: - Supporting Views

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.secondary)
            
            TextField("Search apps...", text: $text)
                .textFieldStyle(PlainTextFieldStyle())
            
            if !text.isEmpty {
                Button("Clear") {
                    text = ""
                }
                .foregroundColor(.secondary)
            }
        }
        .padding(8)
        .background(Color(.systemGray6))
        .cornerRadius(10)
        .padding(.horizontal)
    }
}

struct AppRowView: View {
    let app: App
    
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(app.name)
                    .font(.headline)
                
                Text(app.category)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text(app.description)
                    .font(.caption)
                    .lineLimit(2)
            }
            
            Spacer()
            
            VStack {
                Text(app.version)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                if app.isInstalled {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                }
            }
        }
        .padding(.vertical, 4)
    }
}

struct VMRowView: View {
    let vm: VirtualMachine
    @ObservedObject var vmVM: VirtualMachineViewModel
    
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(vm.name)
                    .font(.headline)
                
                Text("Status: \\(vm.status)")
                    .font(.caption)
                    .foregroundColor(vm.status == "running" ? .green : .secondary)
                
                Text("\\(vm.cpuCores) CPU • \\(vm.ramMB)MB RAM • \\(vm.diskGB)GB")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            HStack {
                if vmVM.actionInProgress == vm.id {
                    ProgressView()
                        .scaleEffect(0.8)
                } else {
                    if vm.status == "stopped" {
                        Button("Start") {
                            vmVM.startVM(vm)
                        }
                        .buttonStyle(.bordered)
                        .tint(.green)
                    } else {
                        Button("Stop") {
                            vmVM.stopVM(vm)
                        }
                        .buttonStyle(.bordered)
                        .tint(.red)
                    }
                }
            }
        }
        .padding(.vertical, 4)
    }
}

struct ProfileView: View {
    @EnvironmentObject var authVM: AuthenticationViewModel
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                if let user = authVM.currentUser {
                    VStack(spacing: 10) {
                        Image(systemName: "person.circle.fill")
                            .font(.system(size: 80))
                            .foregroundColor(.blue)
                        
                        Text(user.username)
                            .font(.title2)
                            .fontWeight(.semibold)
                        
                        if let email = user.email {
                            Text(email)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                
                Spacer()
                
                Button("Logout") {
                    authVM.logout()
                }
                .buttonStyle(.bordered)
                .tint(.red)
            }
            .padding()
            .navigationTitle("Profile")
        }
    }
}`;
  }

  async generateAllFiles() {
    console.log(chalk.blue('🔧 Generating iOS Swift integration files...'));
    
    // Create output directory
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
    
    // Generate files
    const files = [
      { name: 'NetworkService.swift', content: this.generateNetworkService() },
      { name: 'IntegratedViewModels.swift', content: this.generateViewModels() },
      { name: 'IntegratedViews.swift', content: this.generateSwiftUI() }
    ];
    
    files.forEach(file => {
      const filePath = path.join(this.outputDir, file.name);
      fs.writeFileSync(filePath, file.content);
      console.log(chalk.green(`✅ Generated ${file.name}`));
    });
    
    // Generate integration instructions
    const instructions = this.generateIntegrationInstructions();
    fs.writeFileSync(path.join(this.outputDir, 'INTEGRATION_INSTRUCTIONS.md'), instructions);
    console.log(chalk.green('✅ Generated INTEGRATION_INSTRUCTIONS.md'));
    
    console.log(chalk.yellow(`\n📁 All files generated in: ${this.outputDir}`));
  }

  generateIntegrationInstructions() {
    return `# iOS Integration Instructions

## Generated Files

This tool has generated the following Swift files for iOS integration:

1. **NetworkService.swift** - HTTP client for backend API communication
2. **IntegratedViewModels.swift** - View models with Combine publishers
3. **IntegratedViews.swift** - SwiftUI views integrated with backend services

## Integration Steps

### 1. Copy Files to Xcode Project

Copy the generated Swift files to your Xcode project:

\`\`\`bash
# From your project root
cp ios-integration/generated-swift/*.swift ShaydZ-AVMo/Services/
\`\`\`

### 2. Update Network Configuration

The generated code uses localhost URLs. For device testing, update the URLs in \`NetworkService.swift\`:

\`\`\`swift
// Replace localhost with your development machine's IP
private let baseURL = "http://YOUR_LOCAL_IP:8080"
private let authServiceURL = "http://YOUR_LOCAL_IP:8081"
// ... etc
\`\`\`

### 3. Add Required Dependencies

Ensure your project has the necessary frameworks:
- Combine (for reactive programming)
- SwiftUI (for modern UI)

### 4. Replace Existing Views

Update your main app structure to use the integrated views:

\`\`\`swift
// In ShaydZAVMoApp.swift
var body: some Scene {
    WindowGroup {
        IntegratedAppView()
    }
}
\`\`\`

### 5. Configure App Transport Security

Add this to your Info.plist for development (localhost access):

\`\`\`xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
\`\`\`

## Testing Integration

1. **Start Backend Services**:
   \`\`\`bash
   cd demo-production
   docker-compose up -d
   \`\`\`

2. **Run Integration Test**:
   \`\`\`bash
   cd ios-integration
   npm run test:integration
   \`\`\`

3. **Build and Run iOS App**:
   - Open project in Xcode
   - Select simulator or device
   - Build and run (⌘R)

## Default Login Credentials

- Username: \`demo\`
- Password: \`password\`

## API Endpoints

The generated code connects to these services:
- **Auth Service**: http://localhost:8081
- **App Catalog**: http://localhost:8083
- **VM Orchestrator**: http://localhost:8082
- **API Gateway**: http://localhost:8080

## Troubleshooting

### Network Issues
- Ensure backend services are running
- Check firewall settings
- Verify IP addresses for device testing

### Authentication Issues
- Token expires in 1 hour
- App automatically handles re-authentication
- Check backend logs for auth errors

### Build Issues
- Clean build folder (⌘⇧K)
- Restart Xcode
- Verify all files are added to target

## Next Steps

1. Customize UI themes and styling
2. Add error handling improvements
3. Implement offline caching
4. Add push notifications
5. Configure production endpoints

For more help, check the backend API documentation and logs.
`;
  }
}

// Run the generator if called directly
if (require.main === module) {
  const generator = new IOSSwiftCodeGenerator();
  generator.generateAllFiles().catch(console.error);
}

module.exports = IOSSwiftCodeGenerator;
